<?xml version="1.0"?>
<typesystem package="sample">
    <primitive-type name="bool"/>
    <primitive-type name="double"/>
    <primitive-type name="int"/>
    <primitive-type name="char"/>
    <primitive-type name="long"/>

    <primitive-type name="Complex" target-lang-api-name="PyComplex">
        <conversion-rule file="complex_conversions.h"/>
        <include file-name="complex.h" location="global"/>
    </primitive-type>

    <primitive-type name="OddBool" target-lang-api-name="PyBool">
        <conversion-rule file="oddbool_conversions.h"/>
        <include file-name="oddbool.h" location="global"/>
    </primitive-type>

    <container-type name="std::pair" type="pair">
        <conversion-rule file="pair_conversions.h"/>
        <include file-name="utility" location="global"/>
    </container-type>
    <container-type name="std::list" type="list">
        <conversion-rule file="list_conversions.h"/>
        <include file-name="list" location="global"/>
    </container-type>
    <container-type name="std::map" type="map">
        <conversion-rule file="map_conversions.h"/>
        <include file-name="map" location="global"/>
    </container-type>

    <enum-type name="Abstract::PrintFormat"/>
    <enum-type name="OverloadedFuncEnum"/>
    <enum-type name="Derived::OtherOverloadedFuncEnum"/>
    <enum-type name="Modifications::OverloadedModFunc"/>
    <enum-type name="ImplicitConv::CtorEnum"/>
    <!-- BUG:
    renaming the ICOverloadedFuncEnum to the same name
    of a global enum causes the generator to confuse the
    two types.
    -->
    <enum-type name="ImplicitConv::ICOverloadedFuncEnum"/>
    <enum-type name="SampleNamespace::Option"/>
    <enum-type name="SampleNamespace::InValue"/>
    <enum-type name="SampleNamespace::OutValue"/>
    <enum-type name="GlobalEnum"/>
    <enum-type name="GlobalOverloadFuncEnum"/>
    <enum-type name="Overload::FunctionEnum"/>
    <enum-type name="Overload::ParamEnum"/>

    <namespace-type name="SampleNamespace"/>

    <object-type name="Abstract">
        <modify-function signature="id()" rename="id_"/>
    </object-type>

    <object-type name="Derived"/>

    <object-type name="ObjectType"/>

    <template name="boolptr_at_end_fix_beginning">
        bool __ok__;
        %0 = Shiboken::Converter&lt; %RETURN_TYPE &gt;::toPython(
                %CPPSELF.%TYPE::%FUNCTION_NAME(%ARGUMENT_NAMES, &amp;__ok__)
            );
    </template>

    <template name="boolptr_at_start_fix_beginning">
        bool __ok__;
        %0 = Shiboken::Converter&lt; %RETURN_TYPE &gt;::toPython(
                %CPPSELF.%TYPE::%FUNCTION_NAME(&amp;__ok__, %ARGUMENT_NAMES)
            );
    </template>

    <template name="boolptr_fix_end">
        PyObject* _item_;
        PyObject* _tuple_ = PyTuple_New(2);
        PyTuple_SET_ITEM(_tuple_, 0, %0);
        _item_ = Shiboken::Converter&lt;bool&gt;::toPython(__ok__);
        PyTuple_SET_ITEM(_tuple_, 1, _item_);
        return _tuple_;
    </template>

    <object-type name="Modifications">

        <modify-function signature="overloaded(int, bool, int, double)">
            <modify-argument index="2">
                <remove-argument/>
            </modify-argument>
            <inject-code class="native" position="beginning">
                %0 = Shiboken::Converter&lt; %RETURN_TYPE &gt;::toPython(
                        %CPPSELF.%TYPE::%FUNCTION_NAME(%1, true, %3, %4)
                    );
            </inject-code>
        </modify-function>

        <modify-function signature="overloaded(int, bool, int, int)">
            <modify-argument index="3">
                <remove-argument/>
                <replace-default-expression with="321"/>
            </modify-argument>
            <!--
            <modify-argument index="4">
                <remove-default-expression/>
            </modify-argument>
            -->
        </modify-function>

        <!--
        this alteration will trigger an interesting
        compile time error on the binding
        -->
        <!--
        <modify-function signature="overloaded(int, bool, Point, Point)">
            <modify-argument index="3">
                <remove-argument/>
            </modify-argument>
        </modify-function>
        -->

        <!--
        renaming this signature should remove it from the other
        overloaded methods decision tree
        -->
        <modify-function signature="overloaded(int, bool, Point, Point)" rename="over"/>

        <!--
        'ok' must be removed and the return value will be changed
        to a tuple (PyObject*) containing the expected result plus
        the 'ok' value as a Python boolean
        -->
        <modify-function signature="pointToPair(Point, bool*)">
            <modify-argument index="2">
                <remove-argument/>
            </modify-argument>
            <modify-argument index="return">
                <replace-type modified-type="PyObject*"/>
            </modify-argument>
            <inject-code class="native" position="beginning">
                <insert-template name="boolptr_at_end_fix_beginning"/>
            </inject-code>
            <inject-code class="native" position="end">
                <insert-template name="boolptr_fix_end"/>
            </inject-code>
        </modify-function>

        <!-- same as 'pointToPair' except that this time 'ok' is the first argument -->
        <modify-function signature="multiplyPointCoordsPlusValue(bool*, Point, double)">
            <modify-argument index="1">
                <remove-argument/>
            </modify-argument>
            <modify-argument index="return">
                <replace-type modified-type="PyObject*"/>
            </modify-argument>
            <inject-code class="native" position="beginning">
                <insert-template name="boolptr_at_start_fix_beginning"/>
            </inject-code>
            <inject-code class="native" position="end">
                <insert-template name="boolptr_fix_end"/>
            </inject-code>
        </modify-function>

        <!-- completely remove 'plus' from the Python side -->
        <modify-function signature="doublePlus(int, int)">
            <modify-argument index="2">
                <remove-argument/>
            </modify-argument>
        </modify-function>

        <!-- the default value for both arguments must be changed in Python -->
        <modify-function signature="power(int, int)">
            <modify-argument index="1">
                <replace-default-expression with="2"/>
            </modify-argument>
            <modify-argument index="2">
                <replace-default-expression with="1"/>
            </modify-argument>
        </modify-function>

        <!-- in Python set argument default value to 10 -->
        <modify-function signature="timesTen(int)">
            <modify-argument index="1">
                <replace-default-expression with="10"/>
            </modify-argument>
        </modify-function>

        <!-- in Python remove the argument default value -->
        <modify-function signature="increment(int)">
            <modify-argument index="1">
                <remove-default-expression/>
            </modify-argument>
        </modify-function>

        <!-- don't export this method to Python -->
        <modify-function signature="exclusiveCppStuff()" remove="all"/>

        <!-- change the name of this regular method -->
        <modify-function signature="cppMultiply(int, int)" rename="calculateArea"/>

        <!-- change the name of this virtual method -->
        <modify-function signature="className()" rename="name"/>
    </object-type>

    <object-type name="AbstractModifications">
        <!--
        completely removing the pure virtual method from this
        class will generate an #error directive.
        -->
        <!--
        <modify-function signature="pointlessPureVirtualMethod()" remove="all"/>
        -->
    </object-type>

    <value-type name="Reference"/>
    <value-type name="VirtualMethods"/>

    <value-type name="ImplicitConv"/>

    <value-type name="Point">
        <add-function signature="__str__()" return-type="PyObject*">
            <inject-code class="target" position="beginning">
            int x1 = (int) %CPPSELF.x();
            int x2 = ((int) (%CPPSELF.x() * 100)) - (x1 * 100);
            int y1 = (int) %CPPSELF.y();
            int y2 = ((int) (%CPPSELF.y() * 100)) - (y1 * 100);
            %0 = PyString_FromFormat("Point(%d.%d, %d.%d)", x1, x2, y1, y2);
            </inject-code>
        </add-function>
        <add-function signature="__repr__()" return-type="PyObject*">
            <inject-code class="target" position="beginning">
            int x1 = (int) %CPPSELF.x();
            int x2 = ((int) (%CPPSELF.x() * 10)) - (x1 * 10);
            int y1 = (int) %CPPSELF.y();
            int y2 = ((int) (%CPPSELF.y() * 10)) - (y1 * 10);
            %0 = PyString_FromFormat("&lt;Point object at %p: (%d.%d, %d.%d)&gt;", %CPPSELF, x1, x2, y1, y2);
            </inject-code>
        </add-function>
    </value-type>
    <value-type name="Size"/>
    <value-type name="MapUser"/>
    <value-type name="PairUser"/>
    <value-type name="ListUser"/>
    <value-type name="NonDefaultCtor" />
    <value-type name="OddBoolUser" />
    <value-type name="Overload" />
    <value-type name="Collector" />

    <value-type name="Str">
        <add-function signature="__str__()" return-type="PyObject*">
            <inject-code class="target" position="beginning">
                %0 = PyString_FromString(%CPPSELF.cstring());
            </inject-code>
        </add-function>
        <add-function signature="__len__" >
            <inject-code class="target" position="end">
                return %CPPSELF.size();
            </inject-code>
        </add-function>
        <add-function signature="__getitem__" >
            <inject-code class="target" position="beginning">
                if (_i &lt; 0 || _i >= %CPPSELF.size()) {
                    PyErr_BadArgument();
                    return 0;
                } else {
                    char res[2];
                    res[0] = %CPPSELF.get_char(_i);
                    res[1] = 0;
                    return PyString_FromString(res);
                }
            </inject-code>
        </add-function>
        <add-function signature="__setitem__" >
            <inject-code class="target" position="beginning">
                PyObject* args = Py_BuildValue("(iO)", _i, _value);
                PyObject* result = PyStr_set_char(self, args);
                Py_DECREF(args);
                int ok = result == Py_True;
                if (result) {
                    Py_DECREF(result);
                }
                return !ok ? -1 : 0;
            </inject-code>
        </add-function>
    </value-type>

    <value-type name="SimpleFile">
        <modify-function signature="open()">
            <modify-argument index="return">
                <remove-argument/>
            </modify-argument>
            <inject-code class="native" position="end" file="simplefile_glue.cpp"/>
        </modify-function>
    </value-type>

    <object-type name="PrivateDtor" />

    <interface-type name="MBase1"/>
    <object-type name="MBase2"/>
    <object-type name="MDerived"/>

    <rejection class="ListUser" function-name="createList()"/>
    <rejection class="ListUser" function-name="callCreateList()"/>
    <rejection class="ListUser" function-name="createComplexList(Complex, Complex)"/>
    <rejection class="ListUser" function-name="sumList(std::list&lt;int&gt;)"/>
    <rejection class="ListUser" function-name="sumList(std::list&lt;double&gt;)"/>

    <rejection class="" function-name="gimmeComplexList()"/>
    <rejection class="" function-name="makeCString()"/>
    <rejection class="" function-name="returnCString()"/>
</typesystem>

