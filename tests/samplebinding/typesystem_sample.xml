<?xml version="1.0"?>
<typesystem package="sample">
    <primitive-type name="bool"/>
    <primitive-type name="double"/>
    <primitive-type name="int"/>
    <primitive-type name="unsigned int" />
    <primitive-type name="signed int" />
    <primitive-type name="char"/>
    <primitive-type name="long"/>

    <primitive-type name="Complex" target-lang-api-name="PyComplex">
        <conversion-rule file="complex_conversions.h"/>
        <include file-name="complex.h" location="global"/>
    </primitive-type>

    <primitive-type name="OddBool" target-lang-api-name="PyBool">
        <conversion-rule file="oddbool_conversions.h"/>
        <include file-name="oddbool.h" location="global"/>
    </primitive-type>

    <container-type name="std::pair" type="pair">
        <conversion-rule file="pair_conversions.h"/>
        <include file-name="utility" location="global"/>
    </container-type>
    <container-type name="std::list" type="list">
        <conversion-rule file="list_conversions.h"/>
        <include file-name="list" location="global"/>
    </container-type>
    <container-type name="std::map" type="map">
        <conversion-rule file="map_conversions.h"/>
        <include file-name="map" location="global"/>
    </container-type>

    <enum-type name="Abstract::PrintFormat"/>
    <enum-type name="OverloadedFuncEnum"/>
    <enum-type name="Derived::OtherOverloadedFuncEnum"/>
    <enum-type name="Modifications::OverloadedModFunc"/>
    <enum-type name="ImplicitConv::CtorEnum"/>
    <enum-type name="Time::NumArgs"/>
    <!-- BUG:
    renaming the ICOverloadedFuncEnum to the same name
    of a global enum causes the generator to confuse the
    two types.
    -->
    <enum-type name="ImplicitConv::ICOverloadedFuncEnum"/>
    <enum-type name="SampleNamespace::Option"/>
    <enum-type name="SampleNamespace::InValue"/>
    <enum-type name="SampleNamespace::OutValue"/>
    <enum-type name="GlobalEnum"/>
    <enum-type name="GlobalOverloadFuncEnum"/>
    <enum-type name="Overload::FunctionEnum"/>
    <enum-type name="Overload::ParamEnum"/>
    <enum-type name="Event::EventType"/>

    <namespace-type name="SampleNamespace"/>

    <object-type name="Abstract">
        <modify-function signature="id()" rename="id_"/>
    </object-type>

    <object-type name="Derived"/>

    <object-type name="ObjectType">
        <modify-function signature="event(Event*)">
            <modify-argument index="1" invalidate-after-use="yes"/>
        </modify-function>
    </object-type>
    <value-type name="Event"/>

    <value-type name="KinderGarten">
        <modify-function signature="addChild(ObjectType*)">
            <modify-argument index="1">
                <define-ownership owner="c++"/>
            </modify-argument>
        </modify-function>
        <modify-function signature="releaseChild(ObjectType*)">
            <modify-argument index="return">
                <define-ownership owner="target"/>
            </modify-argument>
        </modify-function>
    </value-type>

    <template name="boolptr_at_end_fix_beginning">
        bool __ok__;
        %0 = %CONVERTTOPYTHON[%RETURN_TYPE](
                %CPPSELF.%TYPE::%FUNCTION_NAME(%ARGUMENT_NAMES, &amp;__ok__)
            );
    </template>

    <template name="boolptr_at_start_fix_beginning">
        bool __ok__;
        %0 = %CONVERTTOPYTHON[%RETURN_TYPE](
                %CPPSELF.%TYPE::%FUNCTION_NAME(&amp;__ok__, %ARGUMENT_NAMES)
            );
    </template>

    <template name="boolptr_fix_end">
        PyObject* _tuple_ = PyTuple_New(2);
        PyTuple_SET_ITEM(_tuple_, 0, %0);
        PyObject* _item_ = %CONVERTTOPYTHON[bool](__ok__);
        PyTuple_SET_ITEM(_tuple_, 1, _item_);
        %0 = _tuple_;
    </template>

    <template name="return_4_arguments_as_tuple">
        %0 = PyTuple_New(4);
        PyTuple_SET_ITEM(%0, 0, %CONVERTTOPYTHON[%ARG1_TYPE](%1));
        PyTuple_SET_ITEM(%0, 1, %CONVERTTOPYTHON[%ARG2_TYPE](%2));
        PyTuple_SET_ITEM(%0, 2, %CONVERTTOPYTHON[%ARG3_TYPE](%3));
        PyTuple_SET_ITEM(%0, 3, %CONVERTTOPYTHON[%ARG4_TYPE](%4));
    </template>

    <template name="return_5_arguments_as_tuple">
        %0 = PyTuple_New(5);
        PyTuple_SET_ITEM(%0, 0, %CONVERTTOPYTHON[%ARG1_TYPE](%1));
        PyTuple_SET_ITEM(%0, 1, %CONVERTTOPYTHON[%ARG2_TYPE](%2));
        PyTuple_SET_ITEM(%0, 2, %CONVERTTOPYTHON[%ARG3_TYPE](%3));
        PyTuple_SET_ITEM(%0, 3, %CONVERTTOPYTHON[%ARG4_TYPE](%4));
        PyTuple_SET_ITEM(%0, 4, %CONVERTTOPYTHON[%ARG5_TYPE](%5));
    </template>

    <template name="return_none">
        %0 = Py_None;
        Py_INCREF(Py_None);
    </template>

    <object-type name="Modifications">

        <modify-function signature="overloaded(int, bool, int, double)">
            <modify-argument index="2">
                <remove-argument/>
            </modify-argument>
            <inject-code class="target" position="beginning">
                %0 = %CONVERTTOPYTHON[%RETURN_TYPE](
                        %CPPSELF.%TYPE::%FUNCTION_NAME(%1, true, %3, %4)
                    );
            </inject-code>
        </modify-function>

        <modify-function signature="overloaded(int, bool, int, int)">
            <modify-argument index="3">
                <remove-argument/>
                <replace-default-expression with="321"/>
            </modify-argument>
            <!--
            <modify-argument index="4">
                <remove-default-expression/>
            </modify-argument>
            -->
        </modify-function>

        <modify-function signature="argRemoval0(int, bool, int, int)">
            <modify-argument index="3">
                <remove-argument/>
                <replace-default-expression with="321"/>
            </modify-argument>
            <modify-argument index="return">
                <replace-type modified-type="PyObject*"/>
            </modify-argument>
            <inject-code class="target" position="end">
                <insert-template name="return_4_arguments_as_tuple"/>
            </inject-code>
        </modify-function>

        <modify-function signature="argRemoval1(int, bool, Point, Point, int)">
            <modify-argument index="3">
                <remove-argument/>
            </modify-argument>
            <modify-argument index="4">
                <remove-argument/>
            </modify-argument>
            <modify-argument index="return">
                <replace-type modified-type="PyObject*"/>
            </modify-argument>
            <inject-code class="target" position="end">
                <insert-template name="return_5_arguments_as_tuple"/>
            </inject-code>
        </modify-function>

        <modify-function signature="argRemoval1(int, bool, int, bool)">
            <inject-code class="target" position="end">
                <insert-template name="return_none"/>
            </inject-code>
        </modify-function>

        <modify-function signature="argRemoval2(int, bool, Point, Point, int)">
            <modify-argument index="3">
                <remove-argument/>
            </modify-argument>
            <modify-argument index="4">
                <remove-argument/>
            </modify-argument>
            <modify-argument index="return">
                <replace-type modified-type="PyObject*"/>
            </modify-argument>
            <inject-code class="target" position="end">
                <insert-template name="return_5_arguments_as_tuple"/>
            </inject-code>
        </modify-function>

        <modify-function signature="argRemoval3(int, Point, bool, Point, int)">
            <modify-argument index="2">
                <remove-argument/>
            </modify-argument>
            <modify-argument index="4">
                <remove-argument/>
            </modify-argument>
            <modify-argument index="return">
                <replace-type modified-type="PyObject*"/>
            </modify-argument>
            <inject-code class="target" position="end">
                <insert-template name="return_5_arguments_as_tuple"/>
            </inject-code>
        </modify-function>

        <modify-function signature="argRemoval4(int, Point, bool, Point, int)">
            <modify-argument index="2">
                <remove-argument/>
                <replace-default-expression with="Point(6, 9)"/>
            </modify-argument>
            <modify-argument index="4">
                <remove-argument/>
            </modify-argument>
            <modify-argument index="return">
                <replace-type modified-type="PyObject*"/>
            </modify-argument>
            <inject-code class="target" position="end">
                <insert-template name="return_5_arguments_as_tuple"/>
            </inject-code>
        </modify-function>

        <modify-function signature="argRemoval5(int, bool, Point, Point, int)">
            <modify-argument index="1">
                <remove-argument/>
                <replace-default-expression with="100"/>
            </modify-argument>
            <modify-argument index="3">
                <remove-argument/>
            </modify-argument>
            <modify-argument index="4">
                <remove-argument/>
            </modify-argument>
            <modify-argument index="return">
                <replace-type modified-type="PyObject*"/>
            </modify-argument>
            <inject-code class="target" position="end">
                <insert-template name="return_5_arguments_as_tuple"/>
            </inject-code>
        </modify-function>

        <modify-function signature="argRemoval5(int, bool, int, bool)">
            <modify-argument index="1">
                <remove-argument/>
                <replace-default-expression with="200"/>
            </modify-argument>
            <modify-argument index="return">
                <replace-type modified-type="PyObject*"/>
            </modify-argument>
            <inject-code class="target" position="end">
                <insert-template name="return_4_arguments_as_tuple"/>
            </inject-code>
        </modify-function>

        <!--
        this alteration will trigger an interesting
        compile time error on the binding
        -->
        <!--
        <modify-function signature="overloaded(int, bool, Point, Point)">
            <modify-argument index="3">
                <remove-argument/>
            </modify-argument>
        </modify-function>
        -->

        <!--
        renaming this signature should remove it from the other
        overloaded methods decision tree
        -->
        <modify-function signature="overloaded(int, bool, Point, Point)" rename="over"/>

        <!--
        'ok' must be removed and the return value will be changed
        to a tuple (PyObject*) containing the expected result plus
        the 'ok' value as a Python boolean
        -->
        <modify-function signature="pointToPair(Point, bool*)">
            <modify-argument index="2">
                <remove-argument/>
            </modify-argument>
            <modify-argument index="return">
                <replace-type modified-type="PyObject*"/>
            </modify-argument>
            <inject-code class="target" position="beginning">
                <insert-template name="boolptr_at_end_fix_beginning"/>
            </inject-code>
            <inject-code class="target" position="end">
                <insert-template name="boolptr_fix_end"/>
            </inject-code>
        </modify-function>

        <!-- same as 'pointToPair' except that this time 'ok' is the first argument -->
        <modify-function signature="multiplyPointCoordsPlusValue(bool*, Point, double)">
            <modify-argument index="1">
                <remove-argument/>
            </modify-argument>
            <modify-argument index="return">
                <replace-type modified-type="PyObject*"/>
            </modify-argument>
            <inject-code class="target" position="beginning">
                <insert-template name="boolptr_at_start_fix_beginning"/>
            </inject-code>
            <inject-code class="target" position="end">
                <insert-template name="boolptr_fix_end"/>
            </inject-code>
        </modify-function>

        <!-- completely remove 'plus' from the Python side -->
        <modify-function signature="doublePlus(int, int)">
            <modify-argument index="2">
                <remove-argument/>
            </modify-argument>
        </modify-function>

        <!-- the default value for both arguments must be changed in Python -->
        <modify-function signature="power(int, int)">
            <modify-argument index="1">
                <replace-default-expression with="2"/>
            </modify-argument>
            <modify-argument index="2">
                <replace-default-expression with="1"/>
            </modify-argument>
        </modify-function>

        <!-- in Python set argument default value to 10 -->
        <modify-function signature="timesTen(int)">
            <modify-argument index="1">
                <replace-default-expression with="10"/>
            </modify-argument>
        </modify-function>

        <!-- in Python remove the argument default value -->
        <modify-function signature="increment(int)">
            <modify-argument index="1">
                <remove-default-expression/>
            </modify-argument>
        </modify-function>

        <!-- don't export this method to Python -->
        <modify-function signature="exclusiveCppStuff()" remove="all"/>

        <!-- change the name of this regular method -->
        <modify-function signature="cppMultiply(int, int)" rename="calculateArea"/>

        <!-- change the name of this virtual method -->
        <modify-function signature="className()" rename="name"/>
    </object-type>

    <object-type name="AbstractModifications">
        <!--
        completely removing the pure virtual method from this
        class will generate an #error directive.
        -->
        <!--
        <modify-function signature="pointlessPureVirtualMethod()" remove="all"/>
        -->
    </object-type>

    <value-type name="Reference"/>
    <value-type name="ImplicitConv"/>

    <value-type name="VirtualMethods">
        <modify-function signature="sum0(int, int, int)" rename="sumThree"/>
        <modify-function signature="sum1(int, int, int)">
            <modify-argument index="3">
                <replace-default-expression with="1000"/>
            </modify-argument>
        </modify-function>
        <modify-function signature="sum2(int, int, int)">
            <modify-argument index="3">
                <remove-argument/>
                <replace-default-expression with="2000"/>
            </modify-argument>
        </modify-function>
        <modify-function signature="sum3(int, int, int)">
            <modify-argument index="2">
                <remove-argument/>
            </modify-argument>
            <inject-code class="target" position="beginning">
                %0 = %CONVERTTOPYTHON[%RETURN_TYPE](
                        %CPPSELF.%TYPE::%FUNCTION_NAME(%1, %1+%3, %3)
                    );
            </inject-code>
        </modify-function>
        <modify-function signature="sum4(int, int, int)">
            <modify-argument index="2">
                <remove-argument/>
                <replace-default-expression with="3000"/>
            </modify-argument>
            <inject-code class="native" position="beginning">
                PyObject* new_arg0 = PyInt_FromLong(PyInt_AS_LONG(%PYARG_1) - %2);
                Py_DECREF(%PYARG_1);
                %PYARG_1 = new_arg0;
            </inject-code>
        </modify-function>
        <modify-function signature="name()">
            <inject-code class="native" position="end">
                PyStr_cptr(%0)->prepend(Str("Pimped"));
            </inject-code>
        </modify-function>
        <modify-function signature="callMe()">
            <inject-code class="native" position="end">
                PyGILState_STATE gil_state = PyGILState_Ensure();
                PyObject_Call(%PYTHON_METHOD_OVERRIDE, %PYTHON_ARGUMENTS, NULL);
                PyGILState_Release(gil_state);
            </inject-code>
        </modify-function>
    </value-type>

    <value-type name="VirtualDtor"/>

    <value-type name="InjectCode">
        <!--
            Various tests for inject codes.
            Note: Some uses of inject code here are used just for testing purposes, consider using the add-function tag.
        -->
        <!--
            Inject the tp_str method using this alternative way
            Tested in InjectCodeTest.testTypeNativeBeginning_TypeTargetBeginning:
        -->
        <inject-code class="native" position="beginning">
        PyObject* InjectCode_tpstr(PyObject*) { return PyString_FromString("Hi! I'm the inject code dummy class."); }
        </inject-code>
        <!--
            Register our tp_str class using another inject code
            Tested in InjectCodeTest.testTypeNativeBeginning_TypeTargetBeginning:
        -->
        <inject-code class="target" position="beginning">
        %PYTHONTYPEOBJECT.tp_str = InjectCode_tpstr;
        </inject-code>

        <!-- Tested in InjectCodeTest.testFunctionTargetBeginning_FunctionTargetEnd -->
        <modify-function signature="simpleMethod1(int, int)">
            <inject-code class="target" position="beginning">
                %1 += 1;
            </inject-code>
            <inject-code class="target" position="end">
                PyObject* tmp = PyString_FromString("end");
                PyString_Concat(&amp;%0, tmp);
                Py_DECREF(tmp);
            </inject-code>
        </modify-function>

        <!-- Tested in InjectCodeTest.testFunctionTargetBeginning -->
        <modify-function signature="simpleMethod2()">
            <inject-code class="target" position="end">
                PyObject* tmp = PyString_FromString("end");
                PyString_Concat(&amp;%0, tmp);
                Py_DECREF(tmp);
            </inject-code>
        </modify-function>

        <!-- Tested in InjectCodeTest.testArgsModification -->
        <modify-function signature="overloadedMethod(int, char**)">
            <modify-argument index="1">
                <replace-type modified-type="PySequence" />
            </modify-argument>
            <modify-argument index="2">
                <remove-argument />
            </modify-argument>
            <inject-code class="target" position="beginning">
                int argc;
                char** argv;
                if (!PySequence_to_argc_argv(%PYARG_1, &amp;argc, &amp;argv)) {
                    PyErr_SetString(PyExc_TypeError, "error");
                    return 0;
                }
                %RETURN_TYPE foo = %CPPSELF.%FUNCTION_NAME(argc, argv);
                %0 = %CONVERTTOPYTHON[%RETURN_TYPE](foo);

                for (int i = 0; i &lt; argc; ++i)
                    delete[] argv[i];
                delete[] argv;
            </inject-code>
        </modify-function>

        <!-- Tested in InjectCodeTest.testArgsModification2 -->
        <modify-function signature="simpleMethod3(int, char**)">
            <modify-argument index="1">
                <replace-type modified-type="PySequence" />
            </modify-argument>
            <modify-argument index="2">
                <remove-argument />
            </modify-argument>
            <inject-code class="target" position="beginning">
                int argc;
                char** argv;
                if (!PySequence_to_argc_argv(%PYARG_1, &amp;argc, &amp;argv)) {
                    PyErr_SetString(PyExc_TypeError, "error");
                    return 0;
                }
                %RETURN_TYPE foo = %CPPSELF.%FUNCTION_NAME(argc, argv);
                %0 = %CONVERTTOPYTHON[%RETURN_TYPE](foo);

                for (int i = 0; i &lt; argc; ++i)
                    delete[] argv[i];
                delete[] argv;
            </inject-code>
        </modify-function>
    </value-type>

    <value-type name="Point">
        <add-function signature="__str__()" return-type="PyObject*">
            <inject-code class="target" position="beginning">
            int x1 = (int) %CPPSELF.x();
            int x2 = ((int) (%CPPSELF.x() * 100)) - (x1 * 100);
            int y1 = (int) %CPPSELF.y();
            int y2 = ((int) (%CPPSELF.y() * 100)) - (y1 * 100);
            %0 = PyString_FromFormat("Point(%d.%d, %d.%d)", x1, x2, y1, y2);
            </inject-code>
        </add-function>
        <add-function signature="__repr__()" return-type="PyObject*">
            <inject-code class="target" position="beginning">
            int x1 = (int) %CPPSELF.x();
            int x2 = ((int) (%CPPSELF.x() * 10)) - (x1 * 10);
            int y1 = (int) %CPPSELF.y();
            int y2 = ((int) (%CPPSELF.y() * 10)) - (y1 * 10);
            %0 = PyString_FromFormat("&lt;Point object at %p: (%d.%d, %d.%d)&gt;", %CPPSELF, x1, x2, y1, y2);
            </inject-code>
        </add-function>
    </value-type>
    <value-type name="Time"/>
    <value-type name="Size"/>
    <value-type name="MapUser"/>
    <value-type name="PairUser"/>
    <value-type name="ListUser"/>
    <value-type name="NonDefaultCtor" />
    <value-type name="OddBoolUser" />
    <value-type name="Overload" />
    <object-type name="Collector" stream="yes"/>

    <value-type name="IntWrapper" />

    <value-type name="Str">
        <add-function signature="__str__()" return-type="PyObject*">
            <inject-code class="target" position="beginning">
                %0 = PyString_FromString(%CPPSELF.cstring());
            </inject-code>
        </add-function>
        <add-function signature="__len__" >
            <inject-code class="target" position="end">
                return %CPPSELF.size();
            </inject-code>
        </add-function>
        <add-function signature="__getitem__" >
            <inject-code class="target" position="beginning">
                if (_i &lt; 0 || _i >= %CPPSELF.size()) {
                    PyErr_BadArgument();
                    return 0;
                } else {
                    char res[2];
                    res[0] = %CPPSELF.get_char(_i);
                    res[1] = 0;
                    return PyString_FromString(res);
                }
            </inject-code>
        </add-function>
        <add-function signature="__setitem__" >
            <inject-code class="target" position="beginning">
                PyObject* args = Py_BuildValue("(iO)", _i, _value);
                PyObject* result = PyStr_set_char(self, args);
                Py_DECREF(args);
                int ok = result == Py_True;
                if (result) {
                    Py_DECREF(result);
                }
                return !ok ? -1 : 0;
            </inject-code>
        </add-function>
    </value-type>

    <value-type name="SimpleFile">
        <modify-function signature="open()">
            <modify-argument index="return">
                <remove-argument/>
            </modify-argument>
            <inject-code class="target" position="end" file="simplefile_glue.cpp"/>
        </modify-function>
    </value-type>

    <object-type name="PrivateDtor" />

    <interface-type name="MBase1"/>
    <object-type name="MBase2"/>
    <object-type name="MDerived"/>

    <value-type name="Echo">
        <add-function signature="echo(const char *)" return-type="PyObject*">
            <inject-code class="target" position="beginning">
                %0 = PyString_FromString(%1);
            </inject-code>
        </add-function>
    </value-type>

    <rejection class="ListUser" function-name="createList()"/>
    <rejection class="ListUser" function-name="callCreateList()"/>
    <rejection class="ListUser" function-name="createComplexList(Complex, Complex)"/>
    <rejection class="ListUser" function-name="sumList(std::list&lt;int&gt;)"/>
    <rejection class="ListUser" function-name="sumList(std::list&lt;double&gt;)"/>

    <rejection class="" function-name="gimmeComplexList()"/>
    <rejection class="" function-name="makeCString()"/>
    <rejection class="" function-name="returnCString()"/>

    <suppress-warning text="::*" />
    <suppress-warning text="horribly broken type '__off64_t'" />
    <suppress-warning text="enum '__codecvt_result' does not have a type entry or is not an enum" />
</typesystem>

